package validation

import (
	"bytes"
	"errors"
	"fmt"
	"reflect"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/adnanbrq/validation/v2/helper"
	"github.com/adnanbrq/validation/v2/rules"
)

// Validator struct contains custom and predefined validation rules along with error messages.
type Validator struct {
	// customRules holds custom validation rules defined by the user.
	customRules map[string]rules.Rule

	// predefinedRules holds predefined validation rules provided by the validation package.
	predefinedRules map[string]rules.Rule

	// messages holds custom error messages for validation errors.
	messages map[string]string

	// fieldMessages holds custom error messages for validation errors of specific fields.
	fieldMessages map[string]string

	// failFast is used to skip upcoming rules if there already is a error
	failFast bool
}

// ErrInvalidInput is returned when the input to the Validate method is not a struct.
var ErrInvalidInput = errors.New("the given input needs to be of type struct")

// getRule retrieves a custom or predefined rule by its name. It returns the rule or a the DefaultRule in case no rule was found
func (v *Validator) getRule(name string) rules.Rule {
	if rule, found := v.customRules[name]; found {
		return rule
	}
	if rule, found := v.predefinedRules[name]; found {
		return rule
	}

	return rules.DefaultRule{}
}

// getErrorMessages converts validation error keys to user-friendly messages, if available.
func (v *Validator) getErrorMessages(fieldName string, errs []string) (messages []string) {
	if len(errs) == 0 {
		return []string{}
	}

	opts := map[string]any{
		"Name": cases.Title(language.English).String(fieldName),
	}

	if len(errs) >= 2 {
		opts["O1"] = errs[1]
	}

	if len(errs) >= 3 {
		opts["O2"] = errs[2]
	}

	buf := bytes.Buffer{}
	msg, ok := v.messages[errs[0]]

	if fieldMsg, hasFieldMsg := v.fieldMessages[fmt.Sprintf("%s.%s", fieldName, errs[0])]; hasFieldMsg {
		msg = fieldMsg
	}

	if ok && len(msg) > 0 {
		if tpl := template.New(fieldName); tpl != nil {
			if t, err := template.New(fieldName).Parse(msg); err == nil && t.Execute(&buf, opts) == nil {
				messages = append(messages, buf.String())
			}
		}
	}

	return
}

// isFieldNullable checks if a field is nullable and if its value is nil or considered null based on helper functions.
func (v *Validator) isFieldNullable(tag string, value interface{}) bool {
	return strings.Contains(tag, "nullable") && (value == nil || helper.IsNull(value))
}

// validateRequiredField checks if a field is required and validates it. If validation fails, it returns an error message.
func (v *Validator) validateRequiredField(fieldName string, value interface{}, tag string) string {
	if strings.Contains(tag, "required") {
		if errs := (rules.RequiredRule{}).Validate(value, nil); len(errs) > 0 {
			if messages := v.getErrorMessages(fieldName, errs); len(messages) > 0 {
				return messages[0]
			}
		}
	}

	return ""
}

// applyRule applies a validation rule to a field value and returns any error messages generated by the rule.
func (v *Validator) applyRule(fieldName, rawRule string, value interface{}) []string {
	split := strings.Split(rawRule, ":")
	ruleName := split[0]
	var ruleOption interface{}

	if len(split) == 2 {
		ruleOption = split[1]
	}

	rule := v.getRule(ruleName)
	errs := rule.Validate(value, ruleOption)
	return v.getErrorMessages(fieldName, errs)
}

// Validate validates the input struct based on the defined rules and returns a map of errors.
func (v *Validator) Validate(input interface{}) (map[string][]string, error) {
	if !helper.IsStruct(input) {
		return map[string][]string{}, ErrInvalidInput
	}

	result := map[string][]string{}
	value := reflect.ValueOf(input)

	for i := 0; i < value.NumField(); i++ {
		fieldName := strings.ToLower(value.Type().Field(i).Name)
		fieldValue := value.Field(i).Interface()
		fieldTag := value.Type().Field(i).Tag.Get("valid")
		fieldRules := strings.Split(fieldTag, "|")

		if v.isFieldNullable(fieldTag, fieldValue) {
			continue
		}

		if err := v.validateRequiredField(fieldName, fieldValue, fieldTag); err != "" {
			result[fieldName] = []string{err}
			continue
		}

		for _, rawRule := range fieldRules {
			if _, ok := result[fieldName]; ok && v.failFast {
				continue
			}

			if errs := v.applyRule(fieldName, rawRule, fieldValue); len(errs) > 0 {
				result[fieldName] = append(result[fieldName], errs...)
			}
		}

		if helper.IsStruct(fieldValue) {
			if errs, _ := v.Validate(fieldValue); len(errs) > 0 {
				for deepField := range errs {
					result[fmt.Sprintf("%s.%s", fieldName, deepField)] = errs[deepField]
				}
			}
		}
	}

	return result, nil
}

// AppendRule can be used to store / add a custom rule. The rule needs to implement the rules.Rule interface
func (v *Validator) AppendRule(rule rules.Rule) *Validator {
	v.customRules[rule.Name()] = rule

	return v
}

// SetMessage will override the default message for the given ruleErr like "no-string", etc.
func (v *Validator) SetMessage(ruleErr, message string) *Validator {
	v.messages[ruleErr] = message

	return v
}

// SetMessage does the same as SetMessage but for specific field on the struct.
func (v *Validator) SetFieldMessage(field, rule, message string) *Validator {
	v.fieldMessages[fmt.Sprintf("%s.%s", field, rule)] = message

	return v
}

// SetMessages can be used for translations and replaces the map of messages with the given map
func (v *Validator) SetMessages(messages map[string]string) *Validator {
	v.messages = messages

	return v
}

// SetFailFast will set the failFast flag. Upcoming rules will be skipped per field if we have at least one error in the list
// This essentially shrinks the length of error messages to a maximum of 1
func (v *Validator) SetFailFast(failFast bool) *Validator {
	v.failFast = failFast

	return v
}

// NewValidator constructs a new Validator with predefined rules and default messages.
func NewValidator() *Validator {
	messages := map[string]string{
		"between":               "must be between {{.O1}} and {{.O2}}",
		"between-invalid-value": "the given value cannot be used for a range check",
		"no-bool":               "is not a bool",
		"default":               "",
		"email":                 "is not a email",
		"json":                  "is not a valid JSON Object",
		"jwt":                   "is not a valid JSON Web Token",
		"min":                   "must be greater than or equal to {{.O1}}",
		"max":                   "must be less than or equal to {{.O1}}",
		"no-numeric":            "is not a number",
		"no-pointer":            "is not a pointer",
		"required":              "is required",
		"no-string":             "is not a string",
		"no-int":                "is not a integer",
		"int-wrong-size":        "value needs to be {{.O1}} bit",
		"no-uint":               "is not a unsigned integer",
		"uint-wrong-size":       "value needs to be {{.O1}} bit",
		"no-float":              "is not a float",
		"float-wrong-size":      "value needs to be {{.O1}} bit",
	}

	predefinedRules := map[string]rules.Rule{}
	ruleBucket := []rules.Rule{
		rules.BetweenRule{},
		rules.BoolRule{},
		rules.DefaultRule{},
		rules.EmailRule{},
		rules.JSONRule{},
		rules.JWTRule{},
		rules.MaxRule{},
		rules.MinRule{},
		rules.NumericRule{},
		rules.PointerRule{},
		rules.RequiredRule{},
		rules.StringRule{},
		rules.IntRule{},
		rules.UintRule{},
		rules.FloatRule{},
	}

	for _, rule := range ruleBucket {
		predefinedRules[rule.Name()] = rule
	}

	return &Validator{
		messages:        messages,
		fieldMessages:   map[string]string{},
		customRules:     map[string]rules.Rule{},
		predefinedRules: predefinedRules,
	}
}
