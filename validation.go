package validation

import (
  "bytes"
  "errors"
  "fmt"
  "golang.org/x/text/language"
  "reflect"
  "strings"
  "text/template"
  "golang.org/x/text/cases"

  "github.com/adnanbrq/validation/helper"
  "github.com/adnanbrq/validation/rules"
)

// Validator struct contains custom and predefined validation rules along with error messages.
type Validator struct {
  // customRules holds custom validation rules defined by the user.
  customRules map[string]rules.Rule

  // predefinedRules holds predefined validation rules provided by the validation package.
  predefinedRules map[string]rules.Rule

  // messages holds custom error messages for validation errors.
  messages map[string]string
}

// ErrInvalidInput is returned when the input to the Validate method is not a struct.
var ErrInvalidInput = errors.New("the given input needs to be of type struct")

// getRule retrieves a custom or predefined rule by its name. It returns the rule or a the DefaultRule in case no rule was found
func (v *Validator) getRule(name string) rules.Rule {
  if rule, found := v.customRules[name]; found {
    return rule
  }
  if rule, found := v.predefinedRules[name]; found {
    return rule
  }

  return rules.DefaultRule{}
}

// getErrorMessages converts validation error keys to user-friendly messages, if available.
func (v *Validator) getErrorMessages(fieldName string, errs []string) (messages []string) {
  if len(errs) == 0 {
    return []string{}
  }

  opts := map[string]any{
    "Name": cases.Title(language.English).String(fieldName),
  }

  if len(errs) >= 2 {
    opts["O1"] = errs[1]
  }

  if len(errs) >= 3 {
    opts["O2"] = errs[2]
  }

  buf := bytes.Buffer{}
  if msg, ok := v.messages[errs[0]]; ok {
    t := template.Must(template.New("").Parse(msg))
    if err := t.Execute(&buf, opts); err == nil {
      messages = append(messages, buf.String())
    }
  }

  return
}

// isFieldNullable checks if a field is nullable and if its value is nil or considered null based on helper functions.
func (v *Validator) isFieldNullable(tag string, value interface{}) bool {
  return strings.Contains(tag, "nullable") && (value == nil || helper.IsNull(value))
}

// validateRequiredField checks if a field is required and validates it. If validation fails, it returns an error message.
func (v *Validator) validateRequiredField(fieldName string, value interface{}, tag string) string {
  if strings.Contains(tag, "required") {
    if errs := (rules.RequiredRule{}).Validate(value, nil); len(errs) > 0 {
      if messages := v.getErrorMessages(fieldName, errs); len(messages) > 0 {
        return messages[0]
      }
    }
  }

  return ""
}

// applyRule applies a validation rule to a field value and returns any error messages generated by the rule.
func (v *Validator) applyRule(fieldName, rawRule string, value interface{}) []string {
  split := strings.Split(rawRule, ":")
  ruleName := split[0]
  var ruleOption interface{}

  if len(split) == 2 {
    ruleOption = split[1]
  }

  errs := v.getRule(ruleName).Validate(value, ruleOption)
  return v.getErrorMessages(fieldName, errs)
}

// Validate validates the input struct based on the defined rules and returns a map of errors.
func (v *Validator) Validate(input interface{}) (map[string][]string, error) {
  if !helper.IsStruct(input) {
    return map[string][]string{}, ErrInvalidInput
  }

  result := map[string][]string{}
  value := reflect.ValueOf(input)

  for i := 0; i < value.NumField(); i++ {
    fieldName := strings.ToLower(value.Type().Field(i).Name)
    fieldValue := value.Field(i).Interface()
    fieldTag := value.Type().Field(i).Tag.Get("valid")
    fieldRules := strings.Split(fieldTag, "|")

    if v.isFieldNullable(fieldTag, fieldValue) {
      continue
    }

    if err := v.validateRequiredField(fieldName, fieldValue, fieldTag); err != "" {
      result[fieldName] = []string{err}
      continue
    }

    for _, rawRule := range fieldRules {
      if errs := v.applyRule(fieldName, rawRule, fieldValue); len(errs) > 0 {
        result[fieldName] = append(result[fieldName], errs...)
      }
    }

    if helper.IsStruct(fieldValue) {
      if errs, _ := v.Validate(fieldValue); len(errs) > 0 {
        for deepField := range errs {
          result[fmt.Sprintf("%s.%s", fieldName, deepField)] = errs[deepField]
        }
      }
    }
  }

  return result, nil
}

func (v *Validator) AppendRule(rule rules.Rule) *Validator {
  v.customRules[rule.Name()] = rule

  return v
}

func (v *Validator) SetMessage(name, message string) *Validator {
  v.messages[name] = message

  return v
}

func (v *Validator) SetMessages(messages map[string]string) *Validator {
  v.messages = messages

  return v
}

func NewValidator() *Validator {
  messages := map[string]string{
    "between":           "must be between {{.O1}} and {{.O2}}",
    "between-unuseable": "value is not useable",
    "no-bool":           "is not a bool",
    "default":           "",
    "email":             "is not a email",
    "json":              "is not a valid JSON Object",
    "jwt":               "is not a valid JSON Web Token",
    "min":               "must be greater than or equal to {{.O1}}",
    "max":               "must be less than or equal to {{.O1}}",
    "no-numeric":        "is not a number",
    "no-pointer":        "is not a pointer",
    "required":          "is required",
    "no-string":         "is not a string",
  }

  predefinedRules := map[string]rules.Rule{}
  ruleBucket := []rules.Rule{
    rules.BetweenRule{},
    rules.BoolRule{},
    rules.DefaultRule{},
    rules.EmailRule{},
    rules.JSONRule{},
    rules.JWTRule{},
    rules.MaxRule{},
    rules.MinRule{},
    rules.NumericRule{},
    rules.PointerRule{},
    rules.RequiredRule{},
    rules.StringRule{},
  }

  for _, rule := range ruleBucket {
    predefinedRules[rule.Name()] = rule
  }

  return &Validator{
    messages:        messages,
    customRules:     map[string]rules.Rule{},
    predefinedRules: predefinedRules,
  }
}
